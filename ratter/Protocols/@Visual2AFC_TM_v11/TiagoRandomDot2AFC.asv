function [obj] = TiagoRandomDot2AFC(varargin)
obj = class(struct, mfilename, pokesplot, saveload);
%---------------------------------------------------------------
%   BEGIN SECTION COMMON TO ALL PROTOCOLS, DO NOT MODIFY
%---------------------------------------------------------------

% If creating an empty object, return without further ado:
if nargin==0 || (nargin==1 && ischar(varargin{1}) && strcmp(varargin{1}, 'empty')),
    return;
end;

if isa(varargin{1}, mfilename), % If first arg is an object of this class itself, we are
    % Most likely responding to a callback from
    % a SoloParamHandle defined in this mfile.
    if length(varargin) < 2 || ~ischar(varargin{2}),
        error(['If called with a "%s" object as first arg, a second arg, a ' ...
            'string specifying the action, is required\n']);
    else action = varargin{2}; varargin = varargin(3:end);
    end;
else % Ok, regular call with first param being the action string.
    action = varargin{1}; varargin = varargin(2:end);
end;
if ~isstr(action), error('The action parameter must be a string'); end;

GetSoloFunctionArgs(obj);

%---------------------------------------------------------------
%   END OF SECTION COMMON TO ALL PROTOCOLS, MODIFY AFTER THIS LINE
%---------------------------------------------------------------


switch action,
    
    case 'init'
        
        SetGUI(obj, 'init');
        
    case 'prepare_next_trial'
        
        if (n_done_trials < value(nReward)) && dispatcher('get_time') < value(sessionTime)
            fprintf(1, 'Preparing next trial -- making the next state matrix\n');
            
            coherences.value = nonzeros([value(TWENTY)*0.2, value(FORTY)*0.4, value(SIXTY).*0.6,value(EIGHTY).*0.8,value(HUNDRED).*1]);
            
            if (strcmp(stimuliSequence,'RANDOM LIMIT') && value(limitEqualSides) > 0)
                lastSides.value = circshift(value(lastSides),[0,-1]);
                lastSides(end)= value(side);
            end
            
            if (strcmp(stimuliSequence,'RANDOM LIMIT') && value(limitEqualSides) > 0 && sum(value(lastSides))==0) % All last sides were right
                side.value = true;
            elseif (strcmp(stimuliSequence,'RANDOM LIMIT') && value(limitEqualSides) > 0 && sum(value(lastSides))== value(limitEqualSides)) % All last sides were left
                side.value = false;
            else
                side.value = randi(2)==1;
            end
            
            life_time = value(lifeTime);
            coherence = coherences(randi(length(value(coherences))));
            left = value(side);
            stimulus_duration = value(stimuliDuration);
            dot_size = value(dotSize);
            dot_speed = value(dotSpeed);
            dot_density = value(dotDensity);
            dot_level = value(dotsLevel);
            background_level = value(backgroundLevel);
            
            save('c:/ratter/next_trial','coherence','left','stimulus_duration','life_time',...
                );
            % csvwrite('c:/ratter/next_trial.dat',[life_time; coherence; left; stimulus_duration]);
            
            StateMatrixSection(obj, 'next_trial');
            
        else
            fprintf(1, 'Last trial\n');
            StateMatrixSection(obj, 'session_over');
        end
        
    case 'trial_completed'
        fprintf(1, ['\nFrom the beginning of this trial #%d to the\n' ...
            'start of the next, %g seconds elapsed.\n\n'], n_done_trials, ...
            parsed_events.states.state_0(2,1) - parsed_events.states.state_0(1,2));
        
        PokesPlotSection(obj, 'trial_completed');

    case 'update'
        PokesPlotSection(obj, 'update');
        
    case 'restart'
        dispatcher('restart_protocol');
        
    case 'close'
        SetGUI(obj, 'close');
        
    otherwise,
        warning('Unknown action! "%s"\n', action);
        
end;
