classdef RS232DeviceBasic < Programming.Interfaces.VClass
    %RS232DEVICEBASIC Class representing basic device with RS232 interface, with a handful of pre-fab convenience functions.
    %Intended to be used as a 'mixin'
    %
    %% NOTES
    % Class provides utility functions for handling command/response protocols typically used on serial port devices. I.e. simple replies to acknowledge command receipt/execution, terminated replies including after binary data sequences.
    %
    % Note that all reads are actually asynchronous as defined by Matlab serial port object under the hood, but the class refers to
    % reads as 'asynchronous' when the class function is not blocking, and reply is handled via callback or polling outside this class with receiveAvailableXXXData() methods
    %
    % Events 'errorCondSet'/'errorCondReset' are generated and flag errorCondition maintained -- but it's not clear that these will be used/useful -- Vijay Iyer 3/13/10
    % More important is that communication link errors are generated by this class as if they arise from the caller, but with information about the RS232 link error.    
    %
    % Note that all synchronous send/reply pairs use while loop polling to query device for available data, and generate timeout manually. 
    % Ideally could rely on the Timeout property of the serial port object, but the documented ErrorFcn mechanism does not appear to work, which is required to handle cleanup tasks on timeout error.
    %
    % The general/original form of 'robust mode' -- sendRobustCommand() method --  implemented here (by 5AM) is abandoned and left un-working, at moment. This is to be re-considered...does it belong here, or in a higher level class? 
    % A more targeted robust mode, focusing on terminated reply commands, is now implemented and specified/controlled via the robustTerminatedReplyXXX properties
    %
    %  TODO: Add KVPairs documentation from PrepareCommunicationCommand() to each of the public send/receive methods
    %  TODO: Review receiveTerminatedCommandReplyRobust() to see if there is any way to avoid the 'special' case for the 'MATLAB:serial:fread:invalidSIZE' error -- can we prevent this error? is it a Matlab bug?
    %
    %  TODO: Fix handling of replyClass, including handling for async reply operations. Could arguably leave override to the receiveAvailableXXXData() methods
    %  TODO: Consider whether to add in conversion of byte-wise binary data to targeted replyClass /during/ async reply (i.e. in bufferTimerFcn)
    %  TODO (as needed): Handle cases where serial port device binary sent/received message does not match native byte ordering
    %
    %% ***********************************************************************    
    
    %%%Properties user-settable only via constructor %%%%%%%%%%%%%%%%%%%%%%
    properties (SetAccess=private)
        src; %Handle of object mixing this class in        
        
        comPort=[]; %Number specifying Com port
        availableBaudRates; %Array of valid baud rates supported by this device
        standardBaudRate;   %(OPTIONAL) Specify a default baud rate to use if none is given on construction         
        bufferSize; % default to 512 bytes (same as Matlab serial port objecdt)
        deviceErrorResp = ''; % A string reponse that always indicates an error for device
        deviceSimpleResp = ''; % String given as an acknowledgment reply by device
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %% ABSTRACT PROPERTY REALIZATIONS
    properties (GetAccess=protected,Constant)
        setErrorStrategy = 'setEmpty';
    end   
            
    
    %% PUBLIC PROPERTIES
    properties                
        terminatorDefault=''; %Character(s) which signal end of reply for commands sent and for replies to commands from device. Can override for individual send/receive commands.
        skipSendTerminatorDefault=false; %Logical indicating, if true, that terminator should be skipped for send commands (i.e. only applies for receive operations). Can override for individual send commands.
        flushInputDefault = true; %Logical indicating, if true, to flush input buffer before send commands. Can override for individual send commands.
        
        robustTerminatedReplyAttemptsDefault = 1; %Integer value indicating how many times to retry sending command for sendCommand(Simple/String/Binary)Reply() operations. Can override for individual send/receive commands.
        robustTerminatedReplyAttemptIntervalDefault = 0; %Time, in seconds, to delay between attempts for 'robust' sendCommand(Simple/String/Binary)Reply() operations. Can override for individual send/receive commands.
              
        replyTimeoutDefault = 0.5; %Time, in seconds, to wait for reply (and its terminator) to arrive after sending a typical command (which expects a reply). Can override for individual send/receive commands.
        asyncReplyTimeoutDefault = inf; %Time, in seconds, to wait for a asynchronous reply to terminate. Can override for individual send/receive commands
                
        asyncReplyDiscard = false; %Logical indicating, if true, to discard all data received during aysnchronous reply -- i.e. simply flushing data until Terminator arrives.         
    end
    
    %% PROTECTED/PRIVATE PROPERTIES

    properties (Hidden)
        hSerial=[]; %Handle to underlying Matlab serial port object           
    end
    
    properties (SetAccess=private)        
        baudRate;   % defaults to minimum of availableBaudRates
             
        %Values specified by defaults (public properties), but which can be overridden for individual send/receive commands
        skipSendTerminator; 
        replyTimeout;
        asyncReplyTimeout;        
        robustTerminatedReplyAttempts;
        robustTerminatedReplyAttemptInterval;        
        
        replyClass = '';
        numBits = [];
        signed = false;
        
        asyncReplyPending = false; %Logical indicating if an asynchronous reply is pending
        
        regexTerminator=''; %String containing a regular expression to be used as a custom terminator
        useRegexTerminator; %Logical indicating, if true, to use the custom terminator stored in regexTerminator
    end  
    
    
    %% HIDDEN/PROTECTED/PRIVATE PROPERTIES
    
    properties (Hidden)
        robustTerminatedReplyVerbose = false; %Logical indicating, if true, to display information to command line when multiple attempts to send & receive a terminated reply are employed.        
    end
    
    
    
    properties (SetAccess=protected,Hidden)
        bufferTimer = []; % A timer used during async transfers to trigger a read of the serial input buffer                       
        
        asyncReplyCache = []; %Byte-wise representation of data received thus from device during async read
        asyncReplyStartTime; %Stores tic() information recording time at which an async reply command was issued
                       
        %Following are used as part of the original/general 'robust operation' implemented (not fully vetted/supported) at this time -- Vijay Iyer 3/15/10
        asyncPendingCommand = ''; %String indicating the pending async command
        asyncPendingReplyType = ''; %One of {'string','binary'}. Indicates reply type 
        asyncAttempts=[] %Integer indicating how many attempts have been made for a given asynchronous transfer.
        
        initializedFlag=false; %Flag specifying if initialization has occurred
    end
    
    
    properties (Constant, Hidden)
        robustAttempts = 5; % Number of times to attempt RS232 communication (if an error is detected).
        
        replyClassMap = containers.Map({'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'}, ...
            {{8,true},{8,false},{16, true},{16, false},{32, true},{32, false},{64,true},{64,false}});

        serialObjectTimeout=1; %Timeout value, in seconds, to use for the true underyling serial port Timeout property. This is effectively independent of the replyTimeout/asyncReplyTimeout, and represents time to receive data once it's already found available. Ideally, we could force this to generate an error.
    end
    
        
    %% EVENTS
    
    events
        asyncReplyReceived; %Event indicating expected asynchronous reply has been terminated 
    end
    
    
    %% CONSTRUCTOR/DESTRUCTOR
    methods
        function obj = RS232DeviceBasic(src, varargin)
            
            %import Programming.Utilities.*          
            
            obj.src = src;
            
            pvargs = obj.filterPropValArgs(varargin,{'comPort' 'availableBaudRates' 'standardBaudRate' 'deviceErrorResp' 'deviceSimpleResp'},{'comPort'});
            obj.set(pvargs(1:2:end),pvargs(2:2:end)); %TMW: Annoying this can't be done via abstract superclass or separate function for private/protected properties        
            
            %Determine default/available baud rates, from other, if needed
            if isempty(obj.availableBaudRates) && isempty(obj.standardBaudRate)
                error('At least one of either ''availableBaudRates'' or ''standardBaudRate'' must be specified on construction');
            elseif isempty(obj.availableBaudRates) 
                obj.availableBaudRates = obj.standardBaudRate;
            elseif isempty(obj.standardBaudRate)
                obj.standardBaudRate = min(obj.availableBaudRates);
            end
            
            if ~ismember( obj.standardBaudRate, obj.availableBaudRates)
               error('Specified ''standardBaudRate'' must be among the specified ''availableBaudRates''');
            end
            
            %Test the connection
            try
                hSerialTest = serial(['COM' num2str(obj.comPort)],'BaudRate',obj.standardBaudRate);
                fclose(hSerialTest);
                delete(hSerialTest);
            catch ME
                try  %#ok<TRYNC>
                    delete(hSerialTest);
                end
                error('Unable to open RS232 (serial port) connection on COM port %d. Most likely, the port is already in use. ',obj.comPort);                
            end            
        end
        
        function delete(obj)            
            %Clear serial port object, if any
            if ~isempty(obj.hSerial)
                fclose(obj.hSerial);
                delete(obj.hSerial);
            end
            
            %Clear timer object
            if ~isempty(obj.bufferTimer)
                stop(obj.bufferTimer);
                delete(obj.bufferTimer);
            end
        end
    end
    
    
    %% PROPERTY ACCESS
    methods
        
        function set.baudRate(obj,val)
            assert(ismember(val,obj.availableBaudRates),'Specified ''baudRate'' (%d) is not allowed for device of class %s',val,class(obj));
            obj.baudRate = val;
        end
        
        % Used to set the expected binary format of the reply when calling
        % sendCommandBinaryReply().
        function set.replyClass(obj, val)
            assert(ismember(val,[{''} obj.replyClassMap.keys]), 'Unrecognized ''replyClass'' provided'); %#ok<MCSUP>
            changed = ~strcmpi(val,obj.replyClass);
            
            obj.replyClass = val;            

            %Update numBits/signed values if needed
            %(This is overwrought but harmless, relic of earlier plans to have a 'default' replyClass permanently cached)
            if changed                
                % DEQ - accessing these properties causes a warning, but I'm
                % ignoring it because making 'numBits' and 'signed' Dependent
                % properties defeats the whole purpose of making them class
                % properties in the first place--we're trying to speed things up.
                if strcmp(obj.replyClass, '')
                    obj.numBits = [];
                    obj.signed = [];
                elseif obj.replyClassMap.isKey(val)
                    vals = obj.replyClassMap(val);
                    obj.numBits = vals{1};
                    obj.signed = vals{2};
                else
                    throwAsCaller(MException('','Unrecognized ''replyClass'' provided'));
                end
            end
        end
        
        function set.availableBaudRates(obj,val)
            assert(isnumeric(val) && isvector(val) && all(val)>0 && all(round(val)==val),'Invalid value specified for ''availableBaudRates'' property');
            obj.availableBaudRates = val;
        end
        
        function set.standardBaudRate(obj,val)
            assert(isnumeric(val) && isscalar(val) && (round(val)==val),'Invalid value specified for ''standardBaudRate'' property');
            obj.standardBaudRate = val;
        end
              
        function set.deviceErrorResp(obj,val)
            assert(ischar(val),'Invalid value specified for ''deviceErrorResp'' property');
        end
        
        function set.deviceSimpleResp(obj,val)
            assert(ischar(val),'Invalid value specified for ''deviceSimpleResp'' property');
        end

    end
    
    
    %% PUBLIC METHODS
    methods  
        function initialize(obj,varargin)
            %Initialize device -- this must occur before communication commands occur
            
            if obj.initializedFlag
                error('RS232 communication interface for object of class %s has already been initialized. This operation can/must only be done once.',class(obj));
            end
            
            pvargs = obj.filterPropValArgs(varargin,{'comPort' 'baudRate' 'bufferSize' 'deviceErrorResp' 'deviceSimpleResp'}, {'comPort'});
            obj.set(pvargs(1:2:end),pvargs(2:2:end)); %TMW: Annoying this can't be done via abstract superclass or separate function for private/protected properties

                                    
            %Set some defaults programatically, if not provided
            if ~ismember('baudRate', pvargs(1:2:end))
                obj.baudRate = obj.standardBaudRate;
            end
            
            %Initialize serial port
            obj.hSerial = serial(['COM' num2str(obj.comPort)],'BaudRate', obj.baudRate);
            %obj.hSerial.ErrorFcn = @obj.replyTimeoutFcn; %TMW: This documented property/capability does not seem to work at all!
            if ~isempty(obj.bufferSize)
                set(obj.hSerial,'InputBufferSize', obj.bufferSize);
            else
                obj.bufferSize = get(obj.hSerial,'InputBufferSize');
            end
            fopen(obj.hSerial); %We go ahead and open it, since most (but not all) serial port properties can be set after port is opened anyway. Remember: this is the 'basic' interface, which covers most cases.
            
            % Setup the buffer timer such that it will trigger approximately
            % once every half-buffer's worth of data.
            % NOTE: this math assumes default 8-N-1 serial port setup
            % half-buffer period = 1.0 / (baudRate / (10 bits per byte) / 0.5*bufferSize)
            halfBufferPeriod = 1.0 / (obj.baudRate / 10 / (0.5 * obj.bufferSize));
            warning off MATLAB:TIMER:RATEPRECISION
            warning off MATLAB:TIMER:STARTDELAYPRECISION
            obj.bufferTimer = timer('TimerFcn', @obj.bufferTimerFcn,'Period', halfBufferPeriod, 'StartDelay', halfBufferPeriod, 'ExecutionMode', 'fixedSpacing');
            warning on MATLAB:TIMER:RATEPRECISION
            warning on MATLAB:TIMER:STARTDELAYPRECISION          
            
            %Set the initialized flag
            obj.initializedFlag = true;
        end
        
        
        function resp = sendRobustCommand(obj, command, replyType, replyClass, isAsync, varargin)       
            % A method implementing robust RS232 communication.  If a serial
            % transfer fails for any reason, the transfer is retried (up to a
            % given number of times). 
            % command: 
            % replyType: One of {'','simple', 'string', 'binary'}. Maps to sendCommand, sendCommandSimpleReply, sendCommandStringReply, sendCommandBinaryReply
            % replyClass: If replyType is 'binary', specify class to decode bytewise data
            % isAsync: Indicates to use async reply. replyType can be one of {'string','binary'} (maybe 'simple'?).            
            
            
            cachedException = []; %Stores an MException to be thrown if subsequent retries fail.
            
            if nargin < 5 || isempty(isAsync)
                isAsync = false;
            end
            if nargin < 4 || isempty(replyClass)
                replyClass = '';
            end
            if nargin < 3 || isempty(replyType)
                replyType = '';
            end
            
            % if called with no arguments, assume that we're retrying a failed asynchronous command
            if nargin == 1
                isAsync = true;
                replyType = obj.asyncPendingReplyType;
                replyClass = obj.replyClass;
            end   
            
            if strcmp(replyType,'binary') && isempty(replyClass)
                error('Logical programming error. ''replyClass'' argument must be supplied if replyType is ''binary''.');
            else
                obj.replyClass = replyClass;
            end

            if isAsync
                if obj.asyncPendingTransfer                   
                    if obj.asyncAttempts <= obj.robustAttempts
                        obj.asyncAttempts = obj.asyncAttempts + 1;
                        
                        obj.sendCommandAsyncReply(obj.asyncPendingCommand, obj.replyClass, varargin{:});
                    else
                        error('An error occured during RS232 communication.');
                    end
                else
                    % setup variables to store necessary information between calls
                    obj.asyncPendingTransfer = true;
                    obj.asyncPendingCommand = command;
                    obj.asyncPendingReplyType = replyType;
                    obj.asyncAttempts = 1;
                    
                    obj.sendCommandAsyncReply(command, obj.replyClass, varargin{:});
                end
            else
                attempts = 1;
                retry = true;
                
                while attempts <= obj.robustAttempts && retry 
                    try
                        % call the appropriate sendCommandXXX() method
                        switch replyType
                            case 'string'
                                resp = obj.sendCommandStringReply(command, varargin{:});
                            case 'simple'
                                obj.sendCommandSimpleReply(command, varargin{:});
                            case 'binary'
                                resp = obj.sendCommandBinaryReply(command, obj.replyClass, varargin{:});
                            case ''                               
                                obj.sendCommand(command, varargin{:});
                            otherwise
                                error('Error: unknown replyType (%s) given.', replyType);
                        end
                    catch ME                      
                        cachedException = ME;
                        obj.errorConditionSet(ME);
                    end 

                    % check if any error conditions have been set
                    % if so, retry                  
                    if obj.errorCondition
                        % reset the errorCondition
                        obj.errorConditionReset();
                        attempts = attempts + 1;

                        if attempts <= obj.robustAttempts
                            retry = true;  
                            warning('Warning: error detected in RS232 communication.  Retrying...');
                        else
                            errorMessage = ['An error occured during RS232 communication: Failing after ' num2str(obj.robustAttempts) ' attempts.'];
                            obj.errorConditionSet(MException('',errorMessage));
                            fprintf(2,'WARNING(%s): %s',class(obj),errorMessage);
                            throwAsCaller(cachedException);    
                        end                 
                    else
                        retry = false;
                    end
                end
            end
             
        end
         
        
        %Removed: Use receiveAvailableXXXData() methods instead -- Vijay Iyer 3/13/10
        %Added by DEQ for async response handling
        %         function val = receiveAsyncResponse(obj)
%         % a 'get' method called by LinearStageControllerBasic to retrieve the
%         % data received during an asynchronous transfer
%             if ~isempty(obj.asyncResponse)
%                val = obj.asyncResponse;
%            else
%                val = '';
%            end
%         end
        
        function sendCommand(obj,command,varargin)
            %Sends command to RS232 device without checking or expecting reply. Note 'command' should be of the type (e.g. char, integer, floating-point) to send to device.
            %   function sendCommand(obj,command,byteOrdering)
            %       command: String of characters or numeric vector, of class                 

            try 
                %Clean things up if async reply is pending
                obj.asyncReplyPendingCheck('silent');                
                
                obj.prepareCommunicationCommand(false,command,varargin);
                obj.sendCommandRaw(command);
            catch ME
                obj.genericErrorHandler(ME);
            end
        end
        
        function sendCommandAsyncReply(obj,command,replyClass,varargin)           
            %Sends command to RS232 device and generate event (asyncReplyReceived) when terminator is received
            %If regexpTerminator is defined, then it will be used
            %TODO: Consider whether to turn on/off this capability
            
            %TODO: Rework replyClass handling
            if nargin < 3 || isempty(replyClass)
                replyClass = ''; %This indicates string reply
            end            
            obj.replyClass = replyClass;
            
            try                       
                %Give warning if another async reply is pending
                obj.asyncReplyPendingCheck('warning');  
                
                %Flush the cache
                obj.asyncReplyCache = [];                 
               
                %Determine whether to bind listener to serial object BytesAvailableFcn prop
                if strcmp(obj.replyClass,'')  %string reply expected      
                    bytesAvailableFcn = @obj.asyncReplyBytesAvailableFcn;
                else
                    bytesAvailableFcn =''; %if we're expecting a binary reply, we can't rely on asyncBytesAvailableFcn (because it's possible that the terminator                 %string exists inside the binary stream)
                end
                obj.hSerial.BytesAvailableFcn = bytesAvailableFcn;                
                
                obj.asyncReplyPending = true; %Flag that async reply is pending.
                
                obj.prepareCommunicationCommand(false,command,varargin);                
                obj.sendCommandRaw(command);               
               
                %Start timer/stopwatch
                obj.asyncReplyStartTime = tic();
                start(obj.bufferTimer);               
            catch ME
                obj.genericErrorHandler(ME);
            end
        end
        
        function sendCommandSimpleReply(obj,command,varargin)
            %Sends command to RS232 device and waits for a terminated string reply. Checks reply to ensure it matches the device's expected 'simple' reply -- as defined by validateSimpleRS232Reply(). Note 'command' should be of the type (e.g. char, integer, floating-point) to send to device.         
            try                    
                %Clean things up if async reply is pending
                obj.asyncReplyPendingCheck('silent');  %Make this silent as often a simple-reply command is used to interrupt a pending asynchronous operation
                
                %                 obj.sendCommandRaw(command,varargin{:});
                %                 obj.validateSimpleRS232Reply(obj.receiveTerminatedCommandReply(false));
                resp='';
                resp = obj.sendCommandReceiveTerminatedReply(command,false,varargin{:});
                obj.validateSimpleRS232Reply(resp);
            catch ME
                obj.genericErrorHandler(ME);               
            end
        end
        
        function resp = sendCommandBinaryReply(obj,command,replyClass,varargin)
            %Sends command to RS232 device and waits for a terminated numeric (binary) reply. Returns this reply for user to check/handle/use. Note 'command' should be of the type (e.g. char, integer, floating-point) to send to device.
            %   replyClass: Class by which binary data is interpred and returned as array
            
            obj.replyClass = replyClass;
            
            try
                %Clean things up if async reply is pending
                obj.asyncReplyPendingCheck('warning');
                
                resp=[];               
                resp = obj.sendCommandReceiveTerminatedReply(command,true,varargin{:});
            catch ME
                obj.genericErrorHandler(ME);
            end    
        end
        
        function resp = sendCommandStringReply(obj,command,varargin)
            %Sends command to RS232 device and waits for a terminated string reply. Returns this reply for user to check/handle/use. Note 'command' should be of the type (e.g. char, integer, floating-point) to send to device.          
            try
                %Clean things up if async reply is pending
                obj.asyncReplyPendingCheck('warning');
                
                resp='';
                resp = obj.sendCommandReceiveTerminatedReply(command,false,varargin{:});
            catch ME
                obj.genericErrorHandler(ME);
            end
        end
        
        function resp = receiveAvailableBinaryData(obj,varargin)
            %Method to receive available binary-formatted data received following sendCommand() and sendCommandAsyncReply() commands
            % If no async reply is pending, then daa from serial object input buffer is retrieved;
            % if async reply is pending, then data from asyncReplyCache is used.
            
            try     
                resp=[];
                bytesAvailable = obj.hSerial.BytesAvailable; 
                
                if bytesAvailable && ~obj.asyncReplyPending %sync read
                    obj.prepareCommunicationCommand(true,'',varargin); 
                    resp = obj.readBinaryRaw(bytesAvailable);
                    resp = obj.convertToReplyClassPriv(resp);                          
                elseif ~isempty(obj.asyncReplyCache) %async read
                    resp = obj.convertToReplyClassPriv(obj.asyncReplyCache);
                else
                    resp = [];
                end
                
                %In all cases, flush async reply cache, eliminating stale data
                obj.asyncReplyCache = []; 
                
            catch ME
                obj.genericErrorHandler(ME);
            end     
        end
        
        function resp = receiveAvailableStringData(obj,varargin)
            %Method to receive available string-formatted data received following sendCommand() and sendCommandAsyncReply() commands
            % If no async reply is pending, then data from serial object input buffer is retrieved;
            % if async reply is ending, then data from asyncReplyCache is used.
            
            try
                resp='';  
                if obj.hSerial.BytesAvailable && ~obj.asyncReplyPending  %sync read
                    obj.prepareCommunicationCommand(true,'',varargin);
                    resp = obj.readStringRaw();
                elseif  ~isempty(obj.asyncReplyCache) %async read
                    resp = sprintf('%c',obj.asyncReplyCache);
                else 
                    resp = '';    
                end
                
                %In all cases, flush async reply cache, eliminating stale data
                obj.asyncReplyCache = []; 
                
            catch ME
                obj.genericErrorHandler(ME);
            end
        end
        
        function abortAsyncReply(obj)
            %Aborts pending asynchronous reply. Any data that was previously buffered remains available to receiveAvailableXXXData() methods.           

            if obj.asyncReplyPending
                obj.asyncReplyCleanup();
                obj.asyncReplyReadAvailable(); %Caches (and flushes) any remaining available data from serial port input buffer
            else
                %Throw an error as this does indicate a logical error by client code -- but do not put the device in an error condition
                error([obj.classNameShort ':AbortAsyncInvalid'], 'Attempted to abort pending asynchronous reply when none is active.');
            end            

        end
        
        function tf = isAwaitingReply(obj)            
            tf = obj.asyncReplyPending;                                  
        end
        
        function flushInputBuffer(obj)
            %Method that clears serial input buffer, discarding any received data in that buffer that has not been processed.
            %If flushInputDefault=true, and is not overridden, this method is automatically invoked at start of all sendXXX() operations.
            
            if obj.hSerial.BytesAvailable
                obj.readBinaryRaw(obj.hSerial.BytesAvailable);
            end
        end        
        
        function outValues = convertToReplyClass(obj,inBytes,replyClass)
            % Converts supplied inBytes into numeric outValues using specified replyClass
            
            obj.replyClass = replyClass; %Updates numBits/signed props via set.replyClass
            
            numBytes = obj.numBits/8;
            numValues = length(inBytes)/numBytes;
            
            assert(rem(length(inBytes),numBytes)==0,'Number of bytes received is not an integer multiple of the reply class data size, as expected.');
            
            outValues = [];
            for i=1:numValues
                newVal = [];
                for j=numBytes:-1:1 %assuming native windows little-endian format %TODO: support variable reply byte ordering
                    newVal = [newVal dec2bin(inBytes((i-1)*numBytes + j),8)];
                end
                newVal = bin2dec(newVal);
                
                %Handle signed case, dealing with twos-complement conversion
                if obj.signed
                    if newVal >= 2^(obj.numBits-1)
                        newVal=newVal-2^(obj.numBits);
                    end
                end
                outValues = [outValues newVal];
            end       
        end

    end

    
    %% PRIVATE METHODS
    methods (Access=private)    
        
        function resp = readBinaryRaw(obj,varargin)
            %Wrapper for serial/fread() call, providing appropriate error behavior on true serial port object timeout
            %All timeout errors detected at this level suggest sudden loss of connection (since the bytes were already determined to be available)
            
            [resp,~,msg] = fread(obj.hSerial,varargin{:});
            if ~isempty(msg)
                obj.genericErrorHandler(MException([obj.classNameShort ':ReadTimeout'],'Timeout occurred during read operation, although data had appeared available. A sudden loss of connection is likely cause.'));
            end                       
        end
        
        function resp = readStringRaw(obj)
            %Wrapper for serial/fgetl() call, providing appropriate error behavior on true serial port object timeout
            %All timeout errors detected at this level suggest sudden loss of connection (since the bytes were already determined to be available)
            
            [resp,~,msg] = fgetl(obj.hSerial);
            if ~isempty(msg)
                obj.genericErrorHandler(MException([obj.classNameShort ':ReadTimeout'],'Timeout occurred during read operation, although data had appeared available. A sudden loss of connection is likely cause.'));
            end
        end
                        
        function sendCommandRaw(obj,command)
            %Sends pre-prepared command to RS232 device without checking reply. 
            
            if ischar(command)
                if obj.skipSendTerminator
                    fprintf(obj.hSerial,'%s',command); %Forcibly remove the implied '\n' that serial\fprintf() includes at end of default format string
                else
                    fprintf(obj.hSerial,command);
                end
            else %numeric vector
                precision = class(command);
                fwrite(obj.hSerial,command,precision); %Note, serial/fwrite does not send terminator character
                
                %Force terminator to be sent, if in use
                if ~isempty(obj.hSerial.Terminator) && ~obj.skipSendTerminator
                    fprintf(obj.hSerial,'');
                end
            end
        end
        
        function resp = sendCommandReceiveTerminatedReply(obj,command,isBinaryReply,varargin)          

            %replyClass argument only required if isBinaryReply is true
            assert(~isBinaryReply || ~isempty(obj.replyClass), 'Logical programming error: ''replyClass'' argument must be supplied if ''isBinaryReply'' is true.');           
            if ~isBinaryReply
                obj.replyClass = '';
            end
            
            %Prepare communication command. Do this once -- don't repeat for any repeat ('robust') attempts to send/receive.
            obj.prepareCommunicationCommand(false,command,varargin);         
            
            %Verify that there is a terminator specified for at least receive portion of send/receive pair
            if isempty(obj.hSerial.Terminator)
                throwAsCaller(MException('','Cannot use method without a Terminator specified for serial device object'));
            end
            
            if obj.robustTerminatedReplyAttempts
                robustAttemptCount = 0;
                resp = receiveTerminatedCommandReplyRobust();
            else
                obj.sendCommandRaw(command)
                resp = obj.receiveTerminatedCommandReply(isBinaryReply);
            end                       
                
            function resp = receiveTerminatedCommandReplyRobust()    
                try     
                    obj.sendCommandRaw(command);
                    resp = obj.receiveTerminatedCommandReply(isBinaryReply);                    
                catch ME
                    if strfind(ME.identifier,'SerialCommandReplyTimeout')
                        if robustAttemptCount < obj.robustTerminatedReplyAttempts                            
                            robustAttemptCount = robustAttemptCount + 1;
                            
                            attemptInterval = obj.robustTerminatedReplyAttemptInterval;                            
                            if attemptInterval
                                pause(attemptInterval);
                            end
                            obj.flushInputBuffer(); %Clear input buffer -- in case reply had started, but not terminated
                            if obj.robustTerminatedReplyVerbose
                                fprintf(2,'WARNING(%s): Attempt # %d to send & receive terminated reply on hardware interface (%s)\n',class(obj.src), robustAttemptCount+1, class(obj));
                            end
                            resp = receiveTerminatedCommandReplyRobust();
                        else
                            obj.VError('','SerialCommandReplyTimeoutRobust', 'Device failed to reply within specified ''replyTimeout'' interval (%g s) on %d successive attempts.',obj.replyTimeout, obj.robustTerminatedReplyAttempts + 1);
                        end
                    elseif strfind(ME.identifier,'MATLAB:serial:fread:invalidSIZE') %Occasionally -- the BytesAvailable appears as 0, leading to 'MATLAB:serial:fread:invalidSIZE' error, even though previous checks should prevent this from ever occurring. -- Vijay Iyer 4/2/10
                        %In this case, we will check again -- once only, and regardless of robustTerminatedReplyAttempts property value
                        pause(0.01); 
                        if ~obj.hSerial.BytesAvailable
                            obj.VError('','ReplyBytesAvailableError','Device appeared to have replied, but data no longer appears available in input buffer');
                        else
                            if obj.robustTerminatedReplyVerbose
                                fprintf(2,'WARNING(%s): Attempt # 2 to receive terminated reply on hardware interface (%s)\n',class(obj.src), class(obj));
                            end
                            try
                                obj.flushInputBuffer(); %Clear input buffer -- in case reply had started, but not terminated 
                                pause(0.01);
                                obj.sendCommandRaw(command);
                                resp = obj.receiveTerminatedCommandReply(isBinaryReply);
                            catch %#ok<CTCH>
                                obj.VError('','ReplyBytesAvailableRepeatError','Twice, device appeared to have replied, but data was unavailable on input buffer when read was attempted ');
                            end                              
                        end                        
                    else
                        ME.rethrow();
                    end
                end                           
            end    
                
        end        
       
        function resp = receiveTerminatedCommandReply(obj,isBinaryReply)
            %NOTE: Method applies only for synchronous read operations, and uses the replyTimeout value
            try
                h1 = tic;

                %Test for timeout by polling - no other way seems possible.
                while ~obj.hSerial.BytesAvailable 
                    if toc(h1) > obj.replyTimeout                       
                        obj.VError('', 'SerialCommandReplyTimeout','Device failed to reply within specified ''replyTimeout'' interval (%g s).',obj.replyTimeout);
                    else
                        pause(0.01); %minimum recommended pause interval
                    end
                end
                
                resp = [];
                
                if isBinaryReply
                    while true
                        resp = [resp obj.readBinaryRaw(obj.hSerial.BytesAvailable)'];                        
                        if obj.checkBufferForTerminator(resp)                           
                            break;                        
                        end

                        if toc(h1) > obj.replyTimeout
                            obj.VError('', 'SerialCommandReplyTimeout','Device failed to reply within specified ''replyTimeout'' interval (%g s).',obj.replyTimeout);
                        end
                        pause(0.01); %minimum recommended pause interval
                    end       
                    
                    %Convert to desired reply class
                    resp = obj.convertToReplyClassPriv(resp);      
                else %string resposnse 
                    resp = obj.readStringRaw(); %This will wait for terminator to arrive, if reply thus far was only partial                    
                end
                
                obj.detectGeneralRS232Error(resp); %Throws an error if reply is a general indicator (across device's command set) that an error has occurred
                
            catch ME
                ME.throwAsCaller();
            end
        end
        
          
        function prepareCommunicationCommand(obj,receiveOnly,command,kvPairs)
            %Generic (common) preparation for send/receive commands.
            %   receiveOnly: Logical true if command is a receive-only command
            %   command: Command to be sent, must be string or valid numeric type. Only applies if receiveOnly=false
            %KV Pairs: (passed on from user-supplied arguments)
            %   terminator: Override terminatorDefault in setting serial port Terminator prop
            %   replyTimeout: Override replyTimeoutDefault in setting serial port Timeout prop
            %   asyncReplyTimeout: Override asyncReplyTimeoutDefault in setting serial port Timeout prop
            %   flushInput: Override flushInputDefault in determining whether to flush input buffer prior to command
            %   skipSendTerminator: Logical indicating whether sending the terminator value, if any (either 'terminator' KV pair or 'terminatorDefault' property), should be skipped
            %   robustTerminatedReplyAttempts: Override robustTerminatedReplyAttemptsDefault in determining number of times to repeat attempt of send/receive pair
            %   robustTerminatedReplyAttemptInterval: Override robustTerminatedReplyAttemptIntervalDefault in determining interval between repeated attempts, if any, of send/receive pair
                   
            
            assert(obj.initializedFlag,'RS232 (serial port) communication interface for device of class %s has not yet been initialized, as required.', class(obj));
            if ~receiveOnly
                assert(ischar(command) || (isnumeric(command) && isvector(command)), 'Command must be either a string or numeric vector');
            end
            
            %Default values, prior to processing overrides
            terminator = obj.terminatorDefault;
            obj.skipSendTerminator = obj.skipSendTerminatorDefault;
            flushInput = obj.flushInputDefault;
            obj.replyTimeout = obj.replyTimeoutDefault;
            obj.asyncReplyTimeout = obj.asyncReplyTimeoutDefault;
            obj.robustTerminatedReplyAttempts = obj.robustTerminatedReplyAttemptsDefault;
            obj.robustTerminatedReplyAttemptInterval = obj.robustTerminatedReplyAttemptIntervalDefault;
            obj.regexTerminator = [];
            obj.useRegexTerminator = false;        
                      
            %Process key-value pairs that can override defaults
            if ~isempty(kvPairs)                
                if mod(length(kvPairs),2) || ~iscellstr(kvPairs(1:2:end)) || ...
                        ~all(ismember(lower(kvPairs(1:2:end)),{'replytimeout' 'asyncreplytimeout' 'terminator' 'flushinput' 'regexterminator' 'robustterminatedreplyattempts' 'robustterminatedreplyattemptinterval'}))
                    ME = obj.VException('','KeyValPairError', 'Must supply valid key-value pairs when supplying optional arguments. Valid keys are: ''replytimeout'' ''asyncreplytimeout'' ''terminator'' ''flushinput'' ''regexterminator'' ''robustterminatedreplyattempts'' ''robustterminatedreplyattemptinterval''}');
                    ME.throwAsCaller();
                end
                
                keys = kvPairs(1:2:end);
                values = kvPairs(2:2:end);
                
                for i=1:length(keys)
                    switch lower(keys{i})
                        case 'terminator'
                            %obj.hSerial.Terminator = values{i};
                            terminator = values{i};
                        case 'replytimeout'
                            %obj.hSerial.Timeout = values{i};
                            obj.replyTimeout = values{i};
                        case 'asyncreplytimeout'
                            obj.asyncReplyTimeout = values{i};
                        case 'flushinput'
                            flushInput = values{i};
                        case 'regexterminator'
                            obj.regexTerminator = values{i};
                            obj.useRegexTerminator = true;
                        case 'robustterminatedreplyattempts'
                            obj.robustTerminatedReplyAttempts = values{i};
                        case 'robustterminatedreplyattemptinterval'
                            obj.robustTerminatedReplyAttemptInterval = values{i};                                                       
                        case 'skipsendterminator'
                            obj.skipSendTerminator = values{i};
                    end                                       
                end                                        
            end
            
            %Set underlying serial port object properties
            obj.hSerial.Terminator = terminator;
            
            %Send-command specific
            if ~receiveOnly
                %Flush data, if indicated
                if flushInput
                   obj.flushInputBuffer();                                    
                end
            end                
        end     
        
        %Created, but decided against converting data on the fly, for now -- Vijay Iyer 3/14/10
        %         function appendAsyncReplyData(obj,replyData)
        %             %Append received byte-wise data (replyData) to formatted asyncReply buffer
        %
        %             if ~isempty(replyData)
        %                 switch lower(obj.asyncPendingReplyType)
        %                     case 'binary'
        %                         obj.asyncReply = [obj.asyncReply; obj.convertToReplyClass(obj.asyncReplyCache)];
        %                     case 'string'
        %                         obj.asyncReply = [obj.asyncReply sprintf('%c',obj.asyncReplyCache)];
        %                 end
        %             end
        %         end
        
       
        function detectGeneralRS232Error(obj,resp) %#ok<INUSD,MANU>      
        % Checks if the device's 'error symbol' was received during serial transfer    
            if ~isempty(obj.deviceErrorResp) && strcmpi(resp(1), obj.deviceErrorResp)   
                obj.VError('','DeviceErrorReply','Reply from RS232 device indicates error -- this typically indicates an invalid or unexpected command was sent');            
            end 
        end
       
        function validateSimpleRS232Reply(obj,resp)           
        % Checks if the device's 'simple reply' symbol was received during
        % serial transfer
            if ~isempty(obj.deviceErrorResp) && ~strcmpi(resp(1), obj.deviceSimpleResp)   
                obj.VError('','UnexpectedReply','Received unexpected reply from RS232 device');
            end
        end 
        
        function genericErrorHandler(obj,ME,flushInputBuffer)        
            %Handler for errors related to the device communication link
            
            if nargin < 3 || isempty(flushInputBuffer)
                flushInputBuffer = true;
            end
            
            if flushInputBuffer
                obj.flushInputBuffer();
            end        
            
            %Set error flag
            obj.errorConditionSet(ME);
            
            %Clean up after pending async reply, if any
            obj.asyncReplyCleanup();
            
            ME.throwAsCaller(); %Will appear as if error arises from class/code using this device interface
        end
        
        function asyncReplyBytesAvailableFcn(obj,~,~)
            % Callback function called when the Terminator arrives in the input
            % buffer
            % NOTE: Applies for only string async replies
            
            %Determine if we are expecting to reach this async reply listener
            expected = obj.asyncReplyPending;
            
            %Cleans all asyncReply resources, include reset of asyncReplyPending
            obj.asyncReplyCleanup()
            
            %If callback was not expected, exit
            if ~expected                
                return;
            end
                        
            % Read any remaining serial buffer contents, and append to asyncReplyCache if appropriate
            obj.asyncReplyReadAvailable();
            
            %%%VI031410A: Removed -- as this shouldn't be necessary%%%%%%%%
            %              % check if the last byte is the terminator (if so, pass up the event)
            %             if obj.checkBufferForTerminator()  %Expect this is always true
            %                 obj.awaitingReplyFlag = false;
            %             else %If no terminator - something is screwed up (BytesAvailableFcn shouldn't have fired)
            %                 %TODO: Determine correct action for this case
            %                 obj.awaitingReplyFlag = false;
            %                 obj.sendRobustCommand();
            %             end
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
            %%%VI031410A: Removed -- decided against pre-converting cached data prior to readout, for now
            % read in the cached data
            %             obj.asyncResponse = [];
            %             if strcmp(obj.asyncPendingReplyType, 'string')
            %                 obj.asyncResponse = obj.receiveAvailableStringData();
            %             elseif strcmp(obj.asyncPendingReplyType, 'binary')
            %                 obj.asyncResponse = obj.receiveAvailableBinaryData();
            %             end
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            
            notify(obj,'asyncReplyReceived');
            
        end
        
        
        function bufferTimerFcn(obj, ~, ~)
            % Callback function called regularly during a serial transfer; the
            % period for the timer is set such that this should fire every
            % half-buffer's worth of time.
            % NOTE: Applies for both string and binary async replies
            
            if ~obj.asyncReplyPending %Ensure this callback is intended
                return;
            end            
                        
            % Retrieve newly available serial buffer contents
            % Read any remaining serial buffer contents, and append to asyncReplyCache if appropriate
            newReplyData = obj.asyncReplyReadAvailable();
            
            %if we're waiting on an async binary reply, we have to check for terminator ourselves (cannot rely on asyncReplyBytesAvailableFcn)
            if strcmpi(obj.asyncPendingReplyType, 'binary')
                if obj.checkBufferForTerminator(newReplyData)
                    obj.asyncReplyCleanup();
                    notify(obj,'asyncReplyReceived');
                end
            end  
            
            %Check if time elapsed exceeds the alotted asyncReplyTimeout value
            if toc(obj.asyncReplyStartTime) > obj.asyncReplyTimeout
                obj.asyncReplyCleanup();
                obj.genericErrorHandler(MException([obj.classNameShort ':SerialCommandAsyncReplyTimeout'],'Device failed to reply within specified ''asyncReplyTimeout'' interval (%d s)',obj.asyncReplyTimeout));
            end            
            
        end   
        
        
        function newReplyData = asyncReplyReadAvailable(obj)
            % Read available serial buffer contents, and append to asyncReplyCache if not in 'discard' mode

            bytesAvailable = get(obj.hSerial, 'BytesAvailable');
            if  bytesAvailable > 0
                newReplyData = obj.readBinaryRaw(bytesAvailable)';
                if ~obj.asyncReplyDiscard
                    obj.asyncReplyCache = [obj.asyncReplyCache newReplyData];
                end
            else
                newReplyData = [];
            end            
        end
        
        function asyncReplyPendingCheck(obj,mode)
            %Cleans up any pending async reply during time of issued command. Depending on mode, may issue warning or generate exception
            %   mode: One of {'warning', 'error', 'silent'}
            
            if obj.asyncReplyPending
                switch mode
                    case 'error'
                        %Generating exception will lead to genericErrorHandler() to clean things up
                        throwAsCaller(MException([obj.classNameShort ':InvalidCommandDuringPendingAsyncResponse'], 'Command issued cannot proceed while an asynchronous response from device remains pending.'));
                    case 'warning'
                        fprintf(2,'WARNING(%s): An asynchronous reply remained pending, but has been aborted. Previously received data is lost\n',mfilename('class'));
                end
                
                %If mode='warning' or 'silent', then we allow command to proceed after cleaning up and flushing asyncReplyCache and input buffer
                obj.asyncReplyCleanup();
                obj.asyncReplyCache = []; %Flush cached input buffer
                obj.flushInputBuffer(); %Flush serial port object input buffer
            end
        end
            
        
        function asyncReplyCleanup(obj)
            %Handler reached upon termination or abort of pending asynchronous reply
            
            %Reset buffer timer and asyncReplyPending flag
            stop(obj.bufferTimer);
            obj.asyncReplyPending = false;
            
            %Reset serial port object BytesAvailableFcn
            obj.hSerial.BytesAvailableFcn = '';
            
            % reset all temporary async vars
            obj.asyncPendingCommand = '';
            obj.asyncPendingReplyType = '';
            obj.asyncAttempts = 1;

        end
        
        % Callback function called when a serial port object timeout occurs.
        %TMW: The ErrorFcn capability of serial port objects does not appear to work, so this function is never reached!
        function replyTimeoutFcn(obj,~,~)
            
            % DEQ: If we're waiting on an async transfer and the serial interface doesn't see the terminator, retry communication
            % This was removed by VI 3/13/10. TODO: Consider whether this is the right idea
                                    
            %             if obj.asyncPendingTransfer && obj.awaitingReplyFlag
            %                 obj.awaitingReplyFlag = false;
            %             end
            
            
            obj.errorConditionSet(obj.VException('','SerialPortTimeout','Serial port object timeout occurred'));                       
            %Ideally, we could generate an error, but this is a callback
        end
           
        % Converts byte-wise data into desired output byte class
        function outValues = convertToReplyClassPriv(obj,inBytes)
            %TODO(5AM): SKIP - Support le and be byte-orderings -- use serial byteOrdering property!
            
            inBytes = obj.stripTerminator(inBytes);
            
            outValues = convertToReplyClass(obj,inBytes,obj.replyClass);
     
        end
        
        function tf = checkBufferForTerminator(obj, bufferIn)        
        % Checks the given buffer (or asyncReplyCache, if none specified) for
        % an instance of the serial terminator specified for the current device.      
        % If the terminator is found, it is stripped from the buffer.

            multiByteTerminator = false;
            tf = false;
            
            if isempty(bufferIn)
                return;
            end
            
            if obj.useRegexTerminator
                multiByteTerminator = true;
                terminator = obj.regexTerminator;
            else
                switch obj.hSerial.Terminator
                    case 'CR'
                        terminator = 13;
                    case 'LF'
                        terminator = 10;
                    case 'CR/LF'
                        multiByteTerminator = true;
                        terminator = [13 10];
                    case 'LF/CR'
                        multiByteTerminator = true;
                        terminator = [10 13];
                    otherwise
                        error('Unsupported serial port object Terminator value detected. Logical programming error.'); %Case of no terminator should have been dispensed with beforehand
                end
            end
            
            % If the current device uses a multi-byte terminator, use a regular
            % expression to find the terminator in the cached serial data.
            if multiByteTerminator               
                index = regexp(num2str(bufferIn), num2str(terminator), 'once');
                if ~isempty(index)
                    tf = true;
                end
            else %single byte terminator
                if bufferIn(end) == terminator
                    tf = true;
                end
            end
        end
        
        function val = stripTerminator(obj, buffer)
        %Utility function to remove the terminator string from the end of a buffer      
            
            if nargin == 1
               buffer = obj.asyncReplyCache;
            end

            switch obj.hSerial.Terminator
                case {'CR', 'LF'}
                    val = buffer(1:end-1);
                case {'CR/LF', 'LF/CR'}
                    val = buffer(1:end-2);
            end
        
        end
        
    end    
 
end

